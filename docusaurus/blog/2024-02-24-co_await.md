---
title: co_await で非同期
date: 2024-02-24
tags: [cpp]
---

c++20 の coroutine うまくいきそう。

<!-- truncate -->

あらためて coroutine による task async await 的なものを試してみたところ、
libuv とうまく組み合わせることができそうです。

## keymap から coroutine を開始する

## promise void と awaiter void

## 再起

## awaiter T と promise T

## ついに動いた

試行錯誤して粘っていたらうまくいった。
suspend せずに即座に処理される場合にもきちんと対応する必要があった。
awaiter が作られるときにはすでに処理が終っているのに終了待ちをしてしまい、
後続が resume されない。
この場合は suspend しないことと、 awaiter 生成時に値を付与する。

あと、final_suspend で処理を止めて、あとで resume することで
資源をクリアする手法。

trait で `R::promise_type` 以外を promise 型に指定するのもよい。

keymap 関数のシグネチャーが以下のようになって、
中で `co_await` が可能になった。

```cpp
using Func = std::function<std::shared_ptr<CoroutineState<void>>()>;
```

ロード中のタブ切り替えや、
lineeditor が modal dialog 的に await するなどができる予定。

